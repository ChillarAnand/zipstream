#summary Introduction: example of zstream usage

= Introduction =

Zipstream aims to provide and easy way to access ZIP files along with zlib in a C++ object oriented style to allow you - well, me also - to integrate ZIP files into 
your application as you were accessing a normal file.

You know, because there is a lot of advantages of using a compression system with random access as a virtual drive for your apps'.

1) The first step is to create a zlib wrapper, and it's almost done. 

2) Then I'll have to write one, two or three classes to access the ZIP files, but take it easy. You could help!!

3) Documentation is necessary.

This is an easy example of zstream usage:

zippy.h

{{{

/**
* Copyright 2011 Victor Egea Hernando
*
* Zipstream is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, version 3 of the License.
*
* Zipstream is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with Zipstream.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ZIPPY_H_
#define ZIPPY_H_

#include <zstream.h>

class zippy{

private:
    // instance
    static zippy *_instance;

public:
	// main entry
	int main( int argc, char *argv[] );
    // get instance
    static zippy &get();

private:
    // print options
    void print_options( void );

};

#endif //ZIPPY_H_


}}}

zippy.cpp

{{{
/**
* Copyright 2011 Victor Egea Hernando
*
* Zipstream is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, version 3 of the License.
*
* Zipstream is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with Zipstream.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "zippy.h"

#include <sstream>

zippy *zippy::_instance = 0;

zippy &zippy::get(){
    if( _instance == 0 ){
        _instance = new zippy();
    }
    return *_instance;
}

int zippy::main(int argc, char*argv[]){
	/*
	 * Buffer streaming
	 */
	// 64 KB of data buffer
	zconf::bytep datab = new zconf::byte[ 1 << 16 ];
	zstream zs( datab, 1 << 16, zstream::fwio, Z_DEFAULT_COMPRESSION );
	// create string to deflate
	std::string data;
	// buffer of data
	char output[ 1 << 10 ];
	// write to the stream
	for( int i=0; i < 1000; i++ ){
		std::stringstream ss;
		ss << i << ": Hello World!!" << std::endl;
		zs.write( (zconf::cbytep) ss.str().c_str(), ss.str().length() );
		// check for errors
		if( zs.flags() & zstream::ferr ){
			std::cerr << zs.error() << std::endl;
			return 1;
		}
	}
	// get number of bytes written
	zconf::uint64 tcount = zs.tcount();
	// close buffer
	zs.close();

	// open zstream to read the buffer
	zs.open( datab, 1 << 16, zstream::frio );

	while( zs.tcount() < tcount ){
		std::cout << zs.tcount() << ";" <<  tcount << std::endl;
		// read the bytes compressed before
		zs.read( (zconf::cbytep) output, 1 << 10 );
		// check for errors
		if( zs.flags() & zstream::ferr ){
			std::cerr << zs.error() << std::endl;
			return 1;
		}else{
			// print output
			output[ zs.gcount() ] = '\0';
			std::cout << "output: " << std::endl << output << std::endl;
		}
	}
	// close stream again
	zs.close();

	/*
	 * Iostream streaming
	 */
	// open zstream
	std::fstream ios( "zstreamtest.bin", std::ios::out | std::ios::binary );
	// check for errors
	if( !ios.is_open() ){
		std::cerr << "error: fstream is not open" << std::endl;
		return 1;
	}
	// fill with some data to apply the offset
	ios << "SOMEOFFSET";
	// open the zstream
	zs.open( ios, 1 << 16, 10, zstream::fwio , Z_DEFAULT_COMPRESSION );
	// write to the stream
	for( int i=0; i < 1000; i++ ){
		std::stringstream ss;
		ss << i << ": Hello World!!" << std::endl;
		zs.write( (zconf::cbytep) ss.str().c_str(), ss.str().length() );
		// check for errors
		if( zs.flags() & zstream::ferr ){
			std::cerr << zs.error() << std::endl;
			return 1;
		}
	}
	// get number of bytes written
	tcount = zs.tcount();
	// close buffer
	zs.close(); ios.close();

	// open zstream to read the buffer
	ios.open( "zstreamtest.bin", std::ios::in | std::ios::binary );
	zs.open( ios, tcount, 10, zstream::frio );

	while( zs.tcount() < tcount ){
		std::cout << zs.tcount() << ";" <<  tcount << std::endl;
		// read the bytes compressed before
		zs.read( (zconf::cbytep) output, 1 << 10 );
		// check for errors
		if( zs.flags() & zstream::ferr ){
			std::cerr << zs.error() << std::endl;
			return 1;
		}else{
			// print output
			output[ zs.gcount() ] = '\0';
			std::cout << "output: " << std::endl << output << std::endl;
		}
	}
	// close stream again
	zs.close(); ios.close();

	return 0;
}

int main( int argc, char *argv[] ){
	return zippy::get().main( argc, argv );
}
}}}